"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[427],{4292:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"docs/developer-resources/api/development","title":"development","description":"Webhook Implementation","source":"@site/docs/docs/developer-resources/api/development.md","sourceDirName":"docs/developer-resources/api","slug":"/docs/developer-resources/api/development","permalink":"/docs/docs/developer-resources/api/development","draft":false,"unlisted":false,"editUrl":"https://github.com/PalisadoesFoundation/talawa-plugin/edit/develop/docs/docs/docs/developer-resources/api/development.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"API Plugin Containerization","permalink":"/docs/developer-resources/api/containerization"},"next":{"title":"App Plugin Development Introduction","permalink":"/docs/developer-resources/app/introduction"}}');var r=t(6070),i=t(7648);const s={},o=void 0,d={},p=[{value:"Webhook Implementation",id:"webhook-implementation",level:2},{value:"Example: Razorpay Webhook Registration and Handler",id:"example-razorpay-webhook-registration-and-handler",level:3},{value:"Refer to your Razorpay plugin code for more details on webhook event handling and security.",id:"refer-to-your-razorpay-plugin-code-for-more-details-on-webhook-event-handling-and-security",level:2},{value:"id: api-development\ntitle: API Plugin Development Guide\nslug: /developer-resources/api/development\nsidebar_position: 3",id:"id-api-developmenttitle-api-plugin-development-guideslug-developer-resourcesapidevelopmentsidebar_position-3",level:2},{value:"Development &amp; Testing Workflow",id:"development--testing-workflow",level:2},{value:"Manifest Configuration",id:"manifest-configuration",level:2},{value:"Complete manifest.json",id:"complete-manifestjson",level:3},{value:"Database Schema Design",id:"database-schema-design",level:2},{value:"schema.ts",id:"schemats",level:3},{value:"GraphQL Implementation",id:"graphql-implementation",level:2},{value:"graphql/types.ts",id:"graphqltypests",level:3},{value:"graphql/queries.ts",id:"graphqlqueriests",level:3},{value:"graphql/mutations.ts",id:"graphqlmutationsts",level:3},{value:"Business Logic Layer",id:"business-logic-layer",level:2},{value:"services/payment.service.ts",id:"servicespaymentservicets",level:3},{value:"Webhook Implementation",id:"webhook-implementation-1",level:2},{value:"webhooks/stripe.ts",id:"webhooksstripets",level:3},{value:"Plugin Entry Point",id:"plugin-entry-point",level:2},{value:"index.ts",id:"indexts",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Resources",id:"resources",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"webhook-implementation",children:"Webhook Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"example-razorpay-webhook-registration-and-handler",children:"Example: Razorpay Webhook Registration and Handler"}),"\n",(0,r.jsx)(n.p,{children:"Register your webhook in the plugin entry point (index.ts):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { webhookRegistry } from '../../webhooks';\nimport { handleRazorpayWebhook } from './webhooks/razorpay';\n\n// ...existing code...\n\nasync function onActivate() {\n  webhookRegistry.register({\n    path: '/plugin/razorpay/webhook',\n    method: 'POST',\n    handler: handleRazorpayWebhook,\n  });\n}\n\nasync function onDeactivate() {\n  webhookRegistry.unregister('/plugin/razorpay/webhook');\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Example webhook handler (webhooks/razorpay.ts):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { FastifyRequest, FastifyReply } from 'fastify';\nimport crypto from 'node:crypto';\n\nexport async function handleRazorpayWebhook(req: FastifyRequest, reply: FastifyReply) {\n  const signature = req.headers['x-razorpay-signature'] as string;\n  const webhookSecret = process.env.RAZORPAY_WEBHOOK_SECRET;\n  const expectedSignature = crypto\n    .createHmac('sha256', webhookSecret!)\n    .update(req.body as string)\n    .digest('hex');\n\n  if (signature !== expectedSignature) {\n    reply.code(400).send({ error: 'Invalid signature' });\n    return;\n  }\n\n  // Handle event\n  const event = req.body;\n  switch (event.event) {\n    case 'payment.captured':\n      // Update payment status in DB\n      break;\n    case 'payment.failed':\n      // Handle failed payment\n      break;\n    default:\n      // Log unhandled event\n      break;\n  }\n\n  reply.send({ received: true });\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"refer-to-your-razorpay-plugin-code-for-more-details-on-webhook-event-handling-and-security",children:"Refer to your Razorpay plugin code for more details on webhook event handling and security."}),"\n",(0,r.jsx)(n.h2,{id:"id-api-developmenttitle-api-plugin-development-guideslug-developer-resourcesapidevelopmentsidebar_position-3",children:"id: api-development\ntitle: API Plugin Development Guide\nslug: /developer-resources/api/development\nsidebar_position: 3"}),"\n",(0,r.jsx)(n.h1,{id:"api-plugin-development-guide",children:"API Plugin Development Guide"}),"\n",(0,r.jsx)(n.p,{children:"Step-by-step guide to building Talawa API plugins."}),"\n",(0,r.jsx)(n.h2,{id:"development--testing-workflow",children:"Development & Testing Workflow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Develop your plugin in the ",(0,r.jsx)(n.code,{children:"available"})," folder"]})," (e.g., ",(0,r.jsx)(n.code,{children:"talawa-api/src/plugin/available/razorpay_gateway/"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use GraphiQL"})," to create a plugin entry in the database. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'mutation CreatePlugin {\n  createPlugin(input: {\n    pluginId: "razorpay"\n  }) {\n    id\n    pluginId\n    isActivated\n    isInstalled\n    backup\n  }\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Activate and test your plugin"})," using the Plugin Store or management UI."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Access and test plugin features"})," via registered GraphQL queries, mutations, and webhooks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Once development is complete"}),", push your plugin to the repository for packaging and distribution."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"manifest-configuration",children:"Manifest Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"complete-manifestjson",children:"Complete manifest.json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Razorpay Payment Gateway",\n  "pluginId": "razorpay",\n  "version": "1.0.0",\n  "description": "A payment gateway plugin that integrates Razorpay for donations and payments within organizations. Provides payment processing, transaction management, and webhook handling.",\n  "author": "Palisadoes Foundation",\n  "main": "index.ts",\n  "extensionPoints": {\n    "graphql": [\n      {\n        "type": "query",\n        "name": "razorpayQueries",\n        "file": "graphql/queries.ts",\n        "builderDefinition": "registerRazorpayQueries",\n        "description": "Register all Razorpay query fields"\n      },\n      {\n        "type": "mutation",\n        "name": "razorpayMutations",\n        "file": "graphql/mutations.ts",\n        "builderDefinition": "registerRazorpayMutations",\n        "description": "Register all Razorpay mutation fields"\n      }\n    ],\n    "database": [\n      {\n        "type": "table",\n        "name": "configTable",\n        "file": "database/tables.ts",\n        "description": "Razorpay configuration settings"\n      },\n      {\n        "type": "table",\n        "name": "transactionsTable",\n        "file": "database/tables.ts",\n        "description": "Payment transactions"\n      },\n      {\n        "type": "table",\n        "name": "ordersTable",\n        "file": "database/tables.ts",\n        "description": "Payment orders"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"database-schema-design",children:"Database Schema Design"}),"\n",(0,r.jsx)(n.h3,{id:"schemats",children:"schema.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { pgTable, serial, text, timestamp, decimal, integer, boolean, pgEnum } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Enums\nexport const paymentStatusEnum = pgEnum('plugin_payment_gateway_status', [\n  'pending',\n  'processing',\n  'completed',\n  'failed',\n  'refunded',\n  'canceled'\n]);\n\nexport const paymentProviderEnum = pgEnum('plugin_payment_gateway_provider', [\n  'stripe',\n  'paypal',\n  'manual'\n]);\n\n// Tables\nexport const payments = pgTable('plugin_payment_gateway_payments', {\n  id: serial('id').primaryKey(),\n  userId: text('user_id').notNull(),\n  organizationId: text('organization_id'),\n  amount: decimal('amount', { precision: 10, scale: 2 }).notNull(),\n  currency: text('currency').notNull().default('USD'),\n  status: paymentStatusEnum('status').notNull().default('pending'),\n  provider: paymentProviderEnum('provider').notNull(),\n  providerPaymentId: text('provider_payment_id').unique(),\n  donationId: integer('donation_id'),\n  eventId: integer('event_id'),\n  description: text('description'),\n  metadata: text('metadata'), // JSON\n  errorMessage: text('error_message'),\n  refundedAmount: decimal('refunded_amount', { precision: 10, scale: 2 }),\n  processingFee: decimal('processing_fee', { precision: 10, scale: 2 }),\n  netAmount: decimal('net_amount', { precision: 10, scale: 2 }),\n  createdAt: timestamp('created_at').defaultNow(),\n  updatedAt: timestamp('updated_at').defaultNow(),\n  completedAt: timestamp('completed_at'),\n});\n\nexport const paymentMethods = pgTable('plugin_payment_gateway_payment_methods', {\n  id: serial('id').primaryKey(),\n  userId: text('user_id').notNull(),\n  provider: paymentProviderEnum('provider').notNull(),\n  providerMethodId: text('provider_method_id').notNull(),\n  type: text('type').notNull(), // card, bank_account\n  last4: text('last4'),\n  brand: text('brand'),\n  expiryMonth: integer('expiry_month'),\n  expiryYear: integer('expiry_year'),\n  isDefault: boolean('is_default').default(false),\n  isActive: boolean('is_active').default(true),\n  createdAt: timestamp('created_at').defaultNow(),\n});\n\nexport const transactions = pgTable('plugin_payment_gateway_transactions', {\n  id: serial('id').primaryKey(),\n  paymentId: integer('payment_id').notNull(),\n  type: text('type').notNull(), // charge, refund, fee\n  amount: decimal('amount', { precision: 10, scale: 2 }).notNull(),\n  currency: text('currency').notNull(),\n  providerTransactionId: text('provider_transaction_id'),\n  status: text('status').notNull(),\n  metadata: text('metadata'),\n  createdAt: timestamp('created_at').defaultNow(),\n});\n\n// Relations\nexport const paymentsRelations = relations(payments, ({ many }) => ({\n  transactions: many(transactions),\n}));\n\nexport const transactionsRelations = relations(transactions, ({ one }) => ({\n  payment: one(payments, {\n    fields: [transactions.paymentId],\n    references: [payments.id],\n  }),\n}));\n"})}),"\n",(0,r.jsx)(n.h2,{id:"graphql-implementation",children:"GraphQL Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"graphqltypests",children:"graphql/types.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { builder } from '../../../graphql/builder';\n\n// Payment Status enum\nbuilder.enumType('PaymentStatus', {\n  values: ['pending', 'processing', 'completed', 'failed', 'refunded', 'canceled'],\n});\n\n// Payment Provider enum\nbuilder.enumType('PaymentProvider', {\n  values: ['stripe', 'paypal', 'manual'],\n});\n\n// Payment object type\nbuilder.objectType('Payment', {\n  description: 'A payment transaction',\n  fields: (t) => ({\n    id: t.exposeID('id', { description: 'Unique payment ID' }),\n    userId: t.exposeString('userId'),\n    amount: t.exposeFloat('amount'),\n    currency: t.exposeString('currency'),\n    status: t.expose('status', { type: 'PaymentStatus' }),\n    provider: t.expose('provider', { type: 'PaymentProvider' }),\n    description: t.exposeString('description', { nullable: true }),\n    processingFee: t.exposeFloat('processingFee', { nullable: true }),\n    netAmount: t.exposeFloat('netAmount', { nullable: true }),\n    createdAt: t.expose('createdAt', { type: 'DateTime' }),\n    completedAt: t.expose('completedAt', { type: 'DateTime', nullable: true }),\n    \n    // Relations\n    transactions: t.field({\n      type: ['Transaction'],\n      resolve: async (payment, _, ctx) => {\n        return await ctx.db.query.transactions.findMany({\n          where: eq(transactions.paymentId, payment.id),\n        });\n      },\n    }),\n  }),\n});\n\n// PaymentMethod object type\nbuilder.objectType('PaymentMethod', {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    provider: t.expose('provider', { type: 'PaymentProvider' }),\n    type: t.exposeString('type'),\n    last4: t.exposeString('last4', { nullable: true }),\n    brand: t.exposeString('brand', { nullable: true }),\n    isDefault: t.exposeBoolean('isDefault'),\n    isActive: t.exposeBoolean('isActive'),\n  }),\n});\n\n// Transaction object type\nbuilder.objectType('Transaction', {\n  fields: (t) => ({\n    id: t.exposeID('id'),\n    type: t.exposeString('type'),\n    amount: t.exposeFloat('amount'),\n    currency: t.exposeString('currency'),\n    status: t.exposeString('status'),\n    createdAt: t.expose('createdAt', { type: 'DateTime' }),\n  }),\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"graphqlqueriests",children:"graphql/queries.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { builder } from '../../../graphql/builder';\nimport { db } from '../../../db';\nimport { payments, paymentMethods } from '../schema';\nimport { eq, and, desc } from 'drizzle-orm';\n\n// Get single payment\nbuilder.queryField('getPayment', (t) =>\n  t.field({\n    type: 'Payment',\n    nullable: true,\n    args: {\n      id: t.arg.id({ required: true }),\n    },\n    authScopes: { authenticated: true },\n    resolve: async (_, args, ctx) => {\n      const payment = await db.query.payments.findFirst({\n        where: eq(payments.id, Number(args.id)),\n      });\n      \n      // Check authorization\n      if (payment && payment.userId !== ctx.userId && !ctx.user.isAdmin) {\n        throw new Error('Unauthorized');\n      }\n      \n      return payment;\n    },\n  })\n);\n\n// List user payments\nbuilder.queryField('listPayments', (t) =>\n  t.field({\n    type: ['Payment'],\n    args: {\n      userId: t.arg.string(),\n      status: t.arg({ type: 'PaymentStatus', required: false }),\n      limit: t.arg.int({ defaultValue: 20 }),\n      offset: t.arg.int({ defaultValue: 0 }),\n    },\n    authScopes: { authenticated: true },\n    resolve: async (_, args, ctx) => {\n      const userId = args.userId || ctx.userId;\n      \n      // Check authorization\n      if (userId !== ctx.userId && !ctx.user.isAdmin) {\n        throw new Error('Unauthorized');\n      }\n      \n      const conditions = [eq(payments.userId, userId)];\n      if (args.status) {\n        conditions.push(eq(payments.status, args.status));\n      }\n      \n      return await db.query.payments.findMany({\n        where: and(...conditions),\n        orderBy: desc(payments.createdAt),\n        limit: args.limit,\n        offset: args.offset,\n      });\n    },\n  })\n);\n\n// Get payment methods\nbuilder.queryField('getPaymentMethods', (t) =>\n  t.field({\n    type: ['PaymentMethod'],\n    authScopes: { authenticated: true },\n    resolve: async (_, __, ctx) => {\n      return await db.query.paymentMethods.findMany({\n        where: and(\n          eq(paymentMethods.userId, ctx.userId),\n          eq(paymentMethods.isActive, true)\n        ),\n      });\n    },\n  })\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"graphqlmutationsts",children:"graphql/mutations.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { builder } from '../../../graphql/builder';\nimport { createPaymentService } from '../services/payment.service';\n\n// Create payment\nbuilder.mutationField('createPayment', (t) =>\n  t.field({\n    type: 'Payment',\n    args: {\n      amount: t.arg.float({ required: true, validate: { min: 0.01 } }),\n      currency: t.arg.string({ defaultValue: 'USD' }),\n      provider: t.arg({ type: 'PaymentProvider', required: true }),\n      paymentMethodId: t.arg.string({ required: true }),\n      description: t.arg.string(),\n      donationId: t.arg.int(),\n      eventId: t.arg.int(),\n    },\n    authScopes: { authenticated: true },\n    resolve: async (_, args, ctx) => {\n      const paymentService = createPaymentService(args.provider);\n      \n      return await paymentService.createPayment({\n        userId: ctx.userId,\n        amount: args.amount,\n        currency: args.currency,\n        paymentMethodId: args.paymentMethodId,\n        description: args.description,\n        donationId: args.donationId,\n        eventId: args.eventId,\n      });\n    },\n  })\n);\n\n// Refund payment\nbuilder.mutationField('refundPayment', (t) =>\n  t.field({\n    type: 'Payment',\n    args: {\n      paymentId: t.arg.id({ required: true }),\n      amount: t.arg.float(), // Partial refund if specified\n      reason: t.arg.string(),\n    },\n    authScopes: { admin: true }, // Only admins can refund\n    resolve: async (_, args, ctx) => {\n      const payment = await db.query.payments.findFirst({\n        where: eq(payments.id, Number(args.paymentId)),\n      });\n      \n      if (!payment) {\n        throw new Error('Payment not found');\n      }\n      \n      if (payment.status !== 'completed') {\n        throw new Error('Can only refund completed payments');\n      }\n      \n      const paymentService = createPaymentService(payment.provider);\n      return await paymentService.refundPayment(\n        payment,\n        args.amount,\n        args.reason\n      );\n    },\n  })\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"business-logic-layer",children:"Business Logic Layer"}),"\n",(0,r.jsx)(n.h3,{id:"servicespaymentservicets",children:"services/payment.service.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import Stripe from 'stripe';\nimport { db } from '../../../db';\nimport { payments, transactions } from '../schema';\nimport { eventEmitter } from '../../../events';\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: '2023-10-16',\n});\n\nexport interface IPaymentService {\n  createPayment(data: CreatePaymentInput): Promise<Payment>;\n  refundPayment(payment: Payment, amount?: number, reason?: string): Promise<Payment>;\n  getPaymentStatus(paymentId: string): Promise<string>;\n}\n\nexport class StripePaymentService implements IPaymentService {\n  async createPayment(data: CreatePaymentInput) {\n    // Create Stripe payment intent\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount: Math.round(data.amount * 100),\n      currency: data.currency.toLowerCase(),\n      payment_method: data.paymentMethodId,\n      confirm: true,\n      metadata: {\n        userId: data.userId,\n        donationId: data.donationId?.toString(),\n        eventId: data.eventId?.toString(),\n      },\n    });\n\n    // Calculate fees\n    const processingFee = data.amount * 0.029 + 0.30; // Stripe fees\n    const netAmount = data.amount - processingFee;\n\n    // Save to database\n    const [payment] = await db.insert(payments).values({\n      userId: data.userId,\n      amount: data.amount.toString(),\n      currency: data.currency,\n      status: 'processing',\n      provider: 'stripe',\n      providerPaymentId: paymentIntent.id,\n      donationId: data.donationId,\n      eventId: data.eventId,\n      description: data.description,\n      processingFee: processingFee.toFixed(2),\n      netAmount: netAmount.toFixed(2),\n    }).returning();\n\n    // Create transaction record\n    await db.insert(transactions).values({\n      paymentId: payment.id,\n      type: 'charge',\n      amount: data.amount.toString(),\n      currency: data.currency,\n      providerTransactionId: paymentIntent.id,\n      status: paymentIntent.status,\n    });\n\n    // Emit event\n    eventEmitter.emit('PAYMENT_CREATED', { payment });\n\n    return payment;\n  }\n\n  async refundPayment(payment: Payment, amount?: number, reason?: string) {\n    const refundAmount = amount || parseFloat(payment.amount);\n    \n    // Create Stripe refund\n    const refund = await stripe.refunds.create({\n      payment_intent: payment.providerPaymentId!,\n      amount: Math.round(refundAmount * 100),\n      reason: reason as any,\n    });\n\n    // Update payment\n    const [updatedPayment] = await db.update(payments)\n      .set({\n        status: refundAmount === parseFloat(payment.amount) ? 'refunded' : 'completed',\n        refundedAmount: refundAmount.toString(),\n        updatedAt: new Date(),\n      })\n      .where(eq(payments.id, payment.id))\n      .returning();\n\n    // Create refund transaction\n    await db.insert(transactions).values({\n      paymentId: payment.id,\n      type: 'refund',\n      amount: refundAmount.toString(),\n      currency: payment.currency,\n      providerTransactionId: refund.id,\n      status: refund.status,\n    });\n\n    // Emit event\n    eventEmitter.emit('PAYMENT_REFUNDED', { payment: updatedPayment, amount: refundAmount });\n\n    return updatedPayment;\n  }\n\n  async getPaymentStatus(paymentId: string): Promise<string> {\n    const paymentIntent = await stripe.paymentIntents.retrieve(paymentId);\n    return paymentIntent.status;\n  }\n}\n\nexport function createPaymentService(provider: string): IPaymentService {\n  switch (provider) {\n    case 'stripe':\n      return new StripePaymentService();\n    default:\n      throw new Error(`Unsupported payment provider: ${provider}`);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"webhook-implementation-1",children:"Webhook Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"webhooksstripets",children:"webhooks/stripe.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { FastifyRequest, FastifyReply } from 'fastify';\nimport Stripe from 'stripe';\nimport { db } from '../../../db';\nimport { payments } from '../schema';\nimport { eq } from 'drizzle-orm';\nimport { eventEmitter } from '../../../events';\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: '2023-10-16',\n});\n\nexport async function handleStripeWebhook(\n  req: FastifyRequest,\n  reply: FastifyReply\n) {\n  const sig = req.headers['stripe-signature'] as string;\n  \n  let event: Stripe.Event;\n  \n  try {\n    event = stripe.webhooks.constructEvent(\n      req.body as string,\n      sig,\n      process.env.STRIPE_WEBHOOK_SECRET!\n    );\n  } catch (err) {\n    console.error('Webhook signature verification failed:', err);\n    return reply.code(400).send({ error: 'Invalid signature' });\n  }\n\n  // Handle event\n  try {\n    switch (event.type) {\n      case 'payment_intent.succeeded':\n        await handlePaymentSuccess(event.data.object as Stripe.PaymentIntent);\n        break;\n        \n      case 'payment_intent.payment_failed':\n        await handlePaymentFailure(event.data.object as Stripe.PaymentIntent);\n        break;\n        \n      case 'charge.refunded':\n        await handleRefund(event.data.object as Stripe.Charge);\n        break;\n        \n      default:\n        console.log(`Unhandled event type: ${event.type}`);\n    }\n    \n    reply.send({ received: true });\n  } catch (err) {\n    console.error('Error processing webhook:', err);\n    reply.code(500).send({ error: 'Webhook processing failed' });\n  }\n}\n\nasync function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {\n  const [payment] = await db.update(payments)\n    .set({\n      status: 'completed',\n      completedAt: new Date(),\n      updatedAt: new Date(),\n    })\n    .where(eq(payments.providerPaymentId, paymentIntent.id))\n    .returning();\n\n  if (payment) {\n    eventEmitter.emit('PAYMENT_COMPLETED', { payment });\n  }\n}\n\nasync function handlePaymentFailure(paymentIntent: Stripe.PaymentIntent) {\n  const [payment] = await db.update(payments)\n    .set({\n      status: 'failed',\n      errorMessage: paymentIntent.last_payment_error?.message,\n      updatedAt: new Date(),\n    })\n    .where(eq(payments.providerPaymentId, paymentIntent.id))\n    .returning();\n\n  if (payment) {\n    eventEmitter.emit('PAYMENT_FAILED', { payment });\n  }\n}\n\nasync function handleRefund(charge: Stripe.Charge) {\n  console.log('Refund processed:', charge.id);\n  // Additional refund handling if needed\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"plugin-entry-point",children:"Plugin Entry Point"}),"\n",(0,r.jsx)(n.h3,{id:"indexts",children:"index.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { IPluginLifecycle } from '../../types';\nimport { db } from '../../db';\nimport { payments, paymentMethods, transactions } from './schema';\nimport { sql } from 'drizzle-orm';\nimport { eventEmitter } from '../../events';\nimport { webhookRegistry } from '../../webhooks';\nimport { handleStripeWebhook } from './webhooks/stripe';\n\n// Import GraphQL definitions\nimport './graphql/types';\nimport './graphql/queries';\nimport './graphql/mutations';\n\nconst PaymentGatewayPlugin: IPluginLifecycle = {\n  async onInstall() {\n    console.log('[Payment Gateway] Installing plugin...');\n    \n    // Create enums\n    await db.execute(sql`\n      CREATE TYPE plugin_payment_gateway_status AS ENUM (\n        'pending', 'processing', 'completed', 'failed', 'refunded', 'canceled'\n      );\n    `);\n    \n    await db.execute(sql`\n      CREATE TYPE plugin_payment_gateway_provider AS ENUM (\n        'stripe', 'paypal', 'manual'\n      );\n    `);\n    \n    // Create tables (handled by Drizzle migrations)\n    console.log('[Payment Gateway] Database schema created');\n  },\n\n  async onActivate() {\n    console.log('[Payment Gateway] Activating plugin...');\n    \n    // Register webhooks\n    webhookRegistry.register({\n      path: '/plugin/payment_gateway/stripe-webhook',\n      method: 'POST',\n      handler: handleStripeWebhook,\n    });\n    \n    // Register event listeners\n    eventEmitter.on('DONATION_CREATED', handleDonationCreated);\n    eventEmitter.on('EVENT_REGISTRATION_CREATED', handleEventRegistration);\n    \n    console.log('[Payment Gateway] Plugin activated');\n  },\n\n  async onDeactivate() {\n    console.log('[Payment Gateway] Deactivating plugin...');\n    \n    // Unregister webhooks\n    webhookRegistry.unregister('/plugin/payment_gateway/stripe-webhook');\n    \n    // Remove event listeners\n    eventEmitter.off('DONATION_CREATED', handleDonationCreated);\n    eventEmitter.off('EVENT_REGISTRATION_CREATED', handleEventRegistration);\n    \n    console.log('[Payment Gateway] Plugin deactivated');\n  },\n\n  async onUninstall() {\n    console.log('[Payment Gateway] Uninstalling plugin...');\n    \n    // Drop tables\n    await db.execute(sql`DROP TABLE IF EXISTS plugin_payment_gateway_transactions CASCADE`);\n    await db.execute(sql`DROP TABLE IF EXISTS plugin_payment_gateway_payment_methods CASCADE`);\n    await db.execute(sql`DROP TABLE IF EXISTS plugin_payment_gateway_payments CASCADE`);\n    \n    // Drop enums\n    await db.execute(sql`DROP TYPE IF EXISTS plugin_payment_gateway_status`);\n    await db.execute(sql`DROP TYPE IF EXISTS plugin_payment_gateway_provider`);\n    \n    console.log('[Payment Gateway] Plugin uninstalled');\n  },\n};\n\n// Event handlers\nasync function handleDonationCreated(data: any) {\n  console.log('[Payment Gateway] Processing donation:', data.id);\n  // Auto-create payment intent for donation\n}\n\nasync function handleEventRegistration(data: any) {\n  console.log('[Payment Gateway] Processing event registration:', data.id);\n  // Handle event registration payment\n}\n\nexport default PaymentGatewayPlugin;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://docs-api.talawa.io/docs/developer-resources/testing",children:"Testing Guide"})}),": Write tests"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://stripe.com/docs/api",children:"Stripe API"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://pothos-graphql.dev",children:"Pothos GraphQL"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://orm.drizzle.team",children:"Drizzle ORM"})}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},7648:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(758);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);